{"version":3,"sources":["noose.js"],"names":["factory","window","document","exports","module","define","amd","Noose","noop","_min","Math","min","_max","max","_unit","defaults","classes","noose","selected","compute","container","containers","ctrl","enabled","mode","move","scroll","scrollEdge","scrollbar","select","shift","start","stop","style","border","zIndex","throttle","[object Object]","opts","self","this","HTMLElement","Object","assign","Error","Array","prototype","slice","call","querySelectorAll","coors","pointer","createElement","position","classList","add","started","throttled","_onStart","e","sameContainer","currentTarget","type","which","element","cCoors","pCoors","nCoors","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","pStart","pEnd","end","updateContainerPosition","updatePointerPosition","x","w","y","h","shiftKey","nTop","top","nBottom","bottom","midX","floor","midY","ctrlKey","lastSelection","display","apply","appendChild","_onMove","cancelable","preventDefault","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","_onEnd","removeChild","forEach","_register","_deregister","remove","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pageY","endX","endY","className","elements","offsetX","offsetY","include","topX","topY","bottomX","bottomY","idx","indexOf","push","removeEventListener","splice","addEventListener","version"],"mappings":"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","file":"noose.js","sourcesContent":["/**\n * Noose\n * \n * version: 1.0.0\n */\n\n(function (factory, window, document) {\n    if (typeof exports === 'object') {\n        // CommonJS\n        module.exports = factory(window, document);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(() => {\n            return factory(window, document);\n        });\n    } else {\n        window.Noose = factory(window, document);\n    }\n}(function (window, document) {\n    'use strict';\n\n    function noop() {}\n    const _min = Math.min;\n    const _max = Math.max;\n    const _unit = 'px';\n\n    // Default options\n    const defaults = {\n        // Classes for styling\n        classes: {\n            noose: 'noose',\n            selected: 'selected'\n        },\n        // Enable/disable computing of selected elements\n        compute: true,\n        // Containing element for the noose\n        container: 'body',\n        // Array of containers registered on this instance.\n        containers: [],\n        // Enable/disable support for ctrl key\n        ctrl: true,\n        // Whether the noose is enabled\n        enabled: true,\n        // The selection mode, part or whole\n        mode: 'touch',\n        // On noose move\n        move: noop,\n        // The amount of pixels to scroll\n        scroll: 10,\n        // The edge offset when scrolling should happen\n        scrollEdge: 10,\n        // The scrollbar size\n        scrollbar: 17,\n        // Elements to select\n        select: '*',\n        // Enabled/disable support for shift key\n        shift: true,\n        // On noose-ing start handler\n        start: noop,\n        // On noose-ing stop handler\n        stop: noop,\n        // Styles for the noose\n        style: {\n            border: '1px dotted #000',\n            zIndex: 1000\n        },\n        // Throttle calls to compute selection\n        throttle: 200\n    };\n\n    class Noose {\n        constructor(container, opts) {\n            const self = this;\n            // Parse arguments\n            if (typeof container === 'object' && container != null && !(container instanceof HTMLElement)) {\n                opts = container;\n                container = null;\n            }\n            opts = self.opts = Object.assign({}, defaults, opts);\n            // Container must be positioned (anything but static)\n            if (typeof container === 'string' || container instanceof HTMLElement) {\n                opts.container = container;\n            }\n            // Get containers\n            if (opts.container instanceof HTMLElement) {\n                self.containers = [opts.container];\n            } else if (typeof opts.container === 'string') {\n                self.containers = Array.prototype.slice.call(document.querySelectorAll(opts.container));\n            } else {\n                throw new Error('Invalid container option');\n            }\n            // Setup states\n            self.coors = {\n                // Relative to document top left origin\n                pointer: {},\n                // Relative to container\n                noose: {},\n                // Relative to document top left origin\n                container: {}\n            };\n            // Create noose\n            const noose = self.noose = document.createElement('div');\n            noose.style.position = 'absolute';\n            noose.style.zIndex = opts.style.zIndex;\n            noose.style.border = opts.style.border;\n            if (opts.classes.noose) {\n                noose.classList.add(opts.classes.noose);\n            }\n            let started = false; // Flag for noose-ing started\n            let throttled = false;\n            self._onStart = function (e) {\n                const sameContainer = e.currentTarget === self.currentTarget;\n                if (opts.enabled &&\n                    (!started || !sameContainer) &&\n                    (e.type !== 'mousedown' || e.which === 1)) {\n                    started = true;\n                    const element = self.currentTarget = e.currentTarget;\n                    const cCoors = self.coors.container;\n                    const pCoors = self.coors.pointer;\n                    const nCoors = self.coors.noose;\n\n                    // Initialize container values\n                    const style = window.getComputedStyle(element);\n                    if (style.position === 'static') {\n                        console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n                    }\n                    // Does the container have scrollbars\n                    if (opts.scroll > 0 && opts.scrollEdge > 0) {\n                        cCoors.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && element.scrollHeight > element.clientHeight;\n                        cCoors.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && element.scrollWidth > element.clientWidth;\n                    } else {\n                        cCoors.scrollX = false;\n                        cCoors.scrollY = false;\n                    }\n                    // Set the max allowed scroll amount\n                    cCoors.maxScrollY = cCoors.scrollY && element.scrollHeight - element.clientHeight || 0;\n                    cCoors.maxScrollX = cCoors.scrollX && element.scrollWidth - element.clientWidth || 0;\n\n                    // Get previous start coors in case we need to restore them\n                    const pStart = pCoors.start;\n                    const pEnd = pCoors.end;\n\n                    // Reset start positions\n                    pCoors.start = null;\n                    nCoors.start = null;\n\n                    self.updateContainerPosition().updatePointerPosition(e);\n                    // If the scrollbar was click then don't start\n                    if (opts.scrollbar &&\n                        ((cCoors.scrollX && pCoors.end.x > (cCoors.x + cCoors.w - opts.scrollbar) ||\n                            cCoors.scrollY && pCoors.end.y > (cCoors.y + cCoors.h - opts.scrollbar)))) {\n                        started = false;\n                        pCoors.start = pStart;\n                        pCoors.end = pEnd;\n                        return;\n                    }\n\n                    // Shift key is pressed, continue noose from previous opposing corner\n                    if (opts.shift && sameContainer && e.shiftKey && pStart) {\n                        const nTop = nCoors.top;\n                        const nBottom = nCoors.bottom;\n                        const midX = Math.floor((pStart.x + pEnd.x) / 2);\n                        const midY = Math.floor((pStart.y + pEnd.y) / 2);\n\n                        nCoors.start = {};\n                        if (pCoors.start.x >= midX && pCoors.start.y < midY) {\n                            // 1st quadrant\n                            pCoors.start.x = _min(pStart.x, pEnd.x);\n                            pCoors.start.y = _max(pStart.y, pEnd.y);\n                            nCoors.start.x = nTop.x;\n                            nCoors.start.y = nBottom.y;\n                        } else if (pCoors.start.x < midX && pCoors.start.y <= midY) {\n                            // 2nd quadrant\n                            pCoors.start.x = _max(pStart.x, pEnd.x);\n                            pCoors.start.y = _max(pStart.y, pEnd.y);\n                            nCoors.start = nBottom;\n                        } else if (pCoors.start.x <= midX && pCoors.start.y > midY) {\n                            // 3rd quadrant\n                            pCoors.start.x = _max(pStart.x, pEnd.x);\n                            pCoors.start.y = _min(pStart.y, pEnd.y);\n                            nCoors.start.x = nBottom.x;\n                            nCoors.start.y = nTop.y;\n                        } else if (pCoors.start.x > midX && pCoors.start.y >= midY) {\n                            // 4th quadrant\n                            pCoors.start.x = _min(pStart.x, pEnd.x);\n                            pCoors.start.y = _min(pStart.y, pEnd.y);\n                            nCoors.start = nTop;\n                        }\n                    }\n\n                    if (opts.ctrl && sameContainer && e.ctrlKey) {\n                        self.lastSelection = self.selected || [];\n                    } else {\n                        self.lastSelection = [];\n                    }\n\n                    noose.style.display = 'none';\n\n                    if (opts.start.apply(self, [e, self.coors]) === false) {\n                        started = false;\n                        pCoors.start = pStart;\n                        pCoors.end = pEnd;\n                        return;\n                    }\n\n                    element.appendChild(noose);\n                }\n            };\n            self._onMove = function (e) {\n                if (opts.enabled) {\n                    if (started && e.currentTarget === self.currentTarget) {\n                        e.cancelable && e.preventDefault();\n                        if (e.type !== 'scroll') {\n                            self.updatePointerPosition(e);\n                        }\n                        self.updateContainerPosition().updateNoosePosition();\n                        // Draw noose\n                        let nTop = self.coors.noose.top;\n                        let nBottom = self.coors.noose.bottom;\n                        noose.style.left = nTop.x + _unit;\n                        noose.style.top = nTop.y + _unit;\n                        noose.style.width = (nBottom.x - nTop.x) + _unit;\n                        noose.style.height = (nBottom.y - nTop.y) + _unit;\n                        noose.style.display = 'block';\n\n                        // Scroll container\n                        let element = self.currentTarget;\n                        let cCoors = self.coors.container;\n                        let pEnd = self.coors.pointer.end;\n                        if (cCoors.scrollY && (pEnd.y - cCoors.y < opts.scrollEdge))\n                            element.scrollTop -= opts.scroll;\n                        else if (cCoors.scrollY && element.scrollTop < cCoors.maxScrollY && (cCoors.y + cCoors.h - pEnd.y < opts.scrollEdge))\n                            element.scrollTop += opts.scroll;\n                        else if (cCoors.scrollX && (pEnd.x - cCoors.x < opts.scrollEdge))\n                            element.scrollLeft -= opts.scroll;\n                        else if (cCoors.scrollX && element.scrollLeft < cCoors.maxScrollX && (cCoors.x + cCoors.w - pEnd.x < opts.scrollEdge))\n                            element.scrollLeft += opts.scroll;\n\n                        if (opts.compute) {\n                            // Compute selection\n                            if (opts.throttle) {\n                                // Throttle calls to compute\n                                if (!throttled) {\n                                    throttled = true;\n                                    setTimeout(function () {\n                                        throttled && self.compute() && opts.move.apply(self, [e, self.coors, self.selected]);\n                                        throttled = false;\n                                    }, opts.throttle);\n                                }\n                            } else {\n                                self.compute();\n                                opts.move.apply(self, [e, self.coors, self.selected]);\n                            }\n                        }\n                    }\n                }\n            };\n            self._onEnd = function (e) {\n                if (self.opts.enabled &&\n                    started &&\n                    (e.type !== 'mouseup' || e.which === 1)) {\n                    started = false;\n                    if (e.currentTarget === self.currentTarget) {\n                        self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n                        throttled = false; // Don't run throttled compute after noose action already completed\n                        opts.compute && self.compute(true);\n                        setTimeout(function () {\n                            opts.stop.apply(self, [e, self.coors, self.selected]);\n                        }, 0);\n                        self.currentTarget.removeChild(noose);\n                    }\n                }\n            };\n            // Register handlers\n            self.containers.forEach(container => {\n                self._register(container);\n            });\n\n            return self;\n        }\n        /**\n         * Destroy this Noose instance.\n         *\n         * @returns {Noose} This instance.\n         */\n        destroy() {\n            const self = this;\n            self.containers.forEach(container => {\n                self._deregister(container);\n            });\n            self.noose.remove();\n            self.noose = null;\n\n            return self;\n        }\n        /**\n         * Update the current container's position.\n         * \n         * @returns {Noose} This instance.\n         */\n        updateContainerPosition() {\n            const cCoors = this.coors.container;\n            const rect = this.currentTarget.getBoundingClientRect();\n            // Get position relative to the document's top left origin\n            cCoors.x = rect.left + window.pageXOffset;\n            cCoors.y = rect.top + window.pageYOffset;\n            cCoors.w = rect.width;\n            cCoors.h = rect.height;\n\n            return this;\n        }\n        /**\n         * Update the current pointer (mouse/touch) position.\n         *\n         * @param {Event} e The event that prompted recalculation of the noose (ie: mousemove, touchmove, or scroll).\n         * @returns {Noose} This instance.\n         */\n        updatePointerPosition(e) {\n            const root = e && e.touches && e.touches[0] || e;\n            const pCoors = this.coors.pointer;\n\n            if (root && typeof root.pageX === 'number') {\n                // Get position relative to the document's top left origin\n\n                // Current position is always end\n                pCoors.end = {\n                    x: root.pageX,\n                    y: root.pageY\n                };\n                // Keep start static\n                if (!pCoors.start) {\n                    pCoors.start = pCoors.end;\n                }\n            }\n\n            return this;\n        }\n        /**\n         * Updates the noose top/bottom position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updateNoosePosition() {\n            const element = this.currentTarget;\n            const pEnd = this.coors.pointer.end;\n            const cCoors = this.coors.container;\n            const nCoors = this.coors.noose;\n            // Pointer and container are both relative to document top left origin.\n            // The noose is positioned absolute relative to the container. So that's\n            // (pointer - container), and also account for the container's scroll position.\n            const endX = _max(pEnd.x - cCoors.x + element.scrollLeft, 0);\n            const endY = _max(pEnd.y - cCoors.y + element.scrollTop, 0);\n\n            if (!nCoors.start) {\n                // Keep start position static\n                nCoors.start = {\n                    x: endX,\n                    y: endY\n                };\n            }\n\n            // Determine top and bottom of the noose\n            // top < bottom\n            nCoors.top = {\n                x: _min(nCoors.start.x, endX),\n                y: _min(nCoors.start.y, endY)\n            };\n            nCoors.bottom = {\n                x: _min(_max(nCoors.start.x, endX), element.scrollWidth),\n                y: _min(_max(nCoors.start.y, endY), element.scrollHeight)\n            };\n\n            return this;\n        }\n        /**\n         * Compute the selected elements within the noose region.\n         *\n         * @returns {Noose} This instance.\n         */\n        compute() {\n            const self = this;\n            // Only do if select is enabled\n            if (self.opts.select) {\n                const className = self.opts.classes.selected;\n                const container = self.currentTarget;\n                const elements = container.querySelectorAll(self.opts.select);\n                const nTop = self.coors.noose.top;\n                const nBottom = self.coors.noose.bottom;\n                const offsetX = self.coors.container.x;\n                const offsetY = self.coors.container.y;\n\n                self.selected = [];\n\n                Array.prototype.forEach.call(elements, function (element) {\n                    if (element === self.noose) return; // Don't include noose\n\n                    let include;\n                    // Get absolute position of element relative to container\n                    const rect = element.getBoundingClientRect();\n                    const topX = rect.left + window.pageXOffset - offsetX + container.scrollLeft;\n                    const topY = rect.top + window.pageYOffset - offsetY + container.scrollTop;\n                    const bottomX = rect.width + topX;\n                    const bottomY = rect.height + topY;\n\n                    if (self.opts.mode === 'fit') {\n                        // Include is entire element is within noose\n                        include = nTop.x <= topX && nTop.y <= topY && nBottom.x >= bottomX && nBottom.y >= bottomY;\n                    } else {\n                        // Include if partially touching\n                        include = !(nTop.x > bottomX || nTop.y > bottomY || nBottom.x < topX || nBottom.y < topY);\n                    }\n\n                    const idx = self.lastSelection.indexOf(element);\n\n                    if (include && idx === -1 || !include && idx !== -1) {\n                        className && element.classList.add(className);\n                        self.selected.push(element);\n                    } else {\n                        className && element.classList.remove(className);\n                    }\n                });\n            }\n\n            return self;\n        }\n        _deregister(container) {\n            container.removeEventListener('mousedown', this._onStart);\n            container.removeEventListener('touchstart', this._onStart);\n            container.removeEventListener('mousemove', this._onMove);\n            container.removeEventListener('touchmove', this._onMove);\n            container.removeEventListener('scroll', this._onMove);\n            container.removeEventListener('mouseup', this._onEnd);\n            container.removeEventListener('touchend', this._onEnd);\n\n            delete container.noose;\n\n            return this;\n        }\n        /**\n         * Deregister a container from the Noose instance.\n         * \n         * @param {HTMLElement} container The container to remove.\n         * @returns {Noose} This instance.\n         */\n        deregister(container) {\n            var idx = this.containers.indexOf(container);\n            if (idx > -1 && typeof container.removeEventListener === 'function') {\n                this._deregister(container);\n                this.containers.splice(idx, 1);\n            }\n            return this;\n        }\n        _register(container) {\n            // Fixing chrome mobile touch event issue\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            container.addEventListener('mousedown', this._onStart);\n            container.addEventListener('touchstart', this._onStart, false);\n            container.addEventListener('mousemove', this._onMove);\n            container.addEventListener('touchmove', this._onMove, false);\n            container.addEventListener('scroll', this._onMove);\n            container.addEventListener('mouseup', this._onEnd);\n            container.addEventListener('touchend', this._onEnd, false);\n\n            return container.noose = this;\n        }\n        /**\n         * Register a container to the Noose instance.\n         * \n         * @param {HTMLElement} container The container to register.\n         * @returns {Noose} This instance.\n         */\n        register(container) {\n            var idx = this.containers.indexOf(container);\n            if (idx === -1 && typeof container.addEventListener === 'function') {\n                this._register(container);\n                this.containers.push(container);\n            }\n            return this;\n        }\n        /**\n         * Get the current version.\n         */\n        static get version() {\n            return '1.0.0';\n        }\n    }\n\n    return Noose;\n}, window, document));\n"]}